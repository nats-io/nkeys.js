/*
 * Copyright 2024 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  createCurve,
  fromCurveSeed,
  fromSeed,
  NKeysErrorCode,
} from "../src/mod.ts";
import {
  assert,
  assertEquals,
} from "https://deno.land/std@0.200.0/assert/mod.ts";
import { assertThrowsErrorCode } from "./util.ts";
import type { CurveKP } from "../src/curve.ts";
import { createAccount } from "../src/nkeys.ts";
import { base32 } from "../src/base32.ts";

Deno.test("curve - transitive parse", () => {
  const seed = "SXABQYG6TLQOAZSOGFIAPFJ6B5ZPUXKK5USV4UGXTULPGLSNTSZWJPTLEI";
  const pub = "XBJKZV6QJMJAN3H3KFL2NFVJEQ4WW22423DKRNYF4OIB6LWHUC4COBP6";
  const kp = fromSeed(new TextEncoder().encode(seed));

  const seed2 = new TextDecoder().decode(kp.getSeed());
  assertEquals(seed, seed2);
  const pub2 = kp.getPublicKey();
  assertEquals(pub, pub2);
});

Deno.test("curve - new", () => {
  const kp = createCurve();
  const seed = kp.getSeed();
  const pub = kp.getPublicKey();

  const kp2 = fromSeed(seed);
  const pub2 = kp2.getPublicKey();
  assertEquals(pub, pub2);
});

Deno.test("curve - encrypt", () => {
  // this is actual data generated by the nkeys go library
  const expected = [
    120,
    107,
    118,
    49,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    103,
    188,
    195,
    73,
    0,
    3,
    119,
    91,
    181,
    167,
    162,
    167,
    105,
    51,
    102,
    84,
    94,
    152,
    189,
    229,
    149,
    222,
    47,
    17,
    149,
    188,
    170,
  ];
  const secret = "SXAESVBNK3UN2O24Z53ZJLFMX5OYHLAAVULRILWXRO775SDYFKI7FM3J7Y";
  const recipient =
    "SXAHMGVNIYUF4CA5G475EN64YWNG32HSIF4MZCPZHV7PAFYTWBE5J5USFE";

  // parse the imported secret and public
  const kp = fromSeed(new TextEncoder().encode(secret));
  const kp2 = fromSeed(new TextEncoder().encode(recipient));
  const pub2 = kp2.getPublicKey();

  // nonce is 24 empty bytes for ease of inspection
  const nonce = new Uint8Array(24);
  const data = new TextEncoder().encode("hello world");

  const enc = kp.seal(data, pub2, nonce);
  assertEquals(enc, new Uint8Array(expected));
});

Deno.test("curve - decrypt", () => {
  // this is actual data generated by the nkeys go library
  const message = [
    120,
    107,
    118,
    49,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    103,
    188,
    195,
    73,
    0,
    3,
    119,
    91,
    181,
    167,
    162,
    167,
    105,
    51,
    102,
    84,
    94,
    152,
    189,
    229,
    149,
    222,
    47,
    17,
    149,
    188,
    170,
  ];
  const sender = "SXAESVBNK3UN2O24Z53ZJLFMX5OYHLAAVULRILWXRO775SDYFKI7FM3J7Y";
  const secret = "SXAHMGVNIYUF4CA5G475EN64YWNG32HSIF4MZCPZHV7PAFYTWBE5J5USFE";

  // parse the imported secret and public
  const kp = fromSeed(new TextEncoder().encode(secret));
  const kp2 = fromSeed(new TextEncoder().encode(sender));
  const senderPK = kp2.getPublicKey();

  const enc = kp.open(new Uint8Array(message), senderPK) ?? new Uint8Array();
  assertEquals(new TextDecoder().decode(enc), "hello world");
});

Deno.test("curve - getSeed() fails if cleared", () => {
  const a = createCurve();
  a.clear();
  assertThrowsErrorCode(() => {
    a.getSeed();
  }, NKeysErrorCode.ClearedPair);
});

Deno.test("curve - clear() clear() is noop", () => {
  const a = createCurve();
  a.clear();
  a.clear();
});

Deno.test("curve - getPublicKey() fails if cleared", () => {
  const a = createCurve();
  a.clear();
  assertThrowsErrorCode(() => {
    a.getPublicKey();
  }, NKeysErrorCode.ClearedPair);
});

Deno.test("curve - seal() fails if cleared", () => {
  const a = createCurve();
  a.clear();
  assertThrowsErrorCode(() => {
    a.seal(new Uint8Array(0), "");
  }, NKeysErrorCode.ClearedPair);
});

Deno.test("curve - seal() adds random nonce", () => {
  const a = createCurve();
  const b = createCurve();
  const pub = b.getPublicKey();
  const msg = a.seal(new Uint8Array(0), pub);
  const nonce = msg.slice(4, 28);
  let sum = 0;
  for (let i = 0; i < nonce.length; i++) {
    sum += nonce[i];
  }
  assert(sum > 0);
});

Deno.test("curve - open() fails if cleared", () => {
  const a = createCurve();
  a.clear();
  assertThrowsErrorCode(() => {
    a.open(new Uint8Array(0), "");
  }, NKeysErrorCode.ClearedPair);
});

Deno.test("curve - open() bad message", () => {
  const a = createCurve();
  assertThrowsErrorCode(() => {
    a.open(new Uint8Array(28), "");
  }, NKeysErrorCode.InvalidEncrypted);
});

Deno.test("curve - open() bad version", () => {
  const a = createCurve();
  assertThrowsErrorCode(() => {
    const m = new Uint8Array(29);
    m.set([120, 107, 118, 50]);
    a.open(m, "");
  }, NKeysErrorCode.InvalidEncrypted);
});

Deno.test("curve - sign() is invalid operation", () => {
  const a = createCurve();
  assertThrowsErrorCode(() => {
    a.sign(new Uint8Array(0));
  }, NKeysErrorCode.InvalidCurveOperation);
});

Deno.test("curve - verify() is invalid operation", () => {
  const a = createCurve();
  assertThrowsErrorCode(() => {
    a.verify(new Uint8Array(0), new Uint8Array(0));
  }, NKeysErrorCode.InvalidCurveOperation);
});

Deno.test("curve - decode bad recipient", () => {
  const a = createCurve() as CurveKP;
  assertThrowsErrorCode(() => {
    a.decodePubCurveKey(createAccount().getPublicKey());
  }, NKeysErrorCode.InvalidRecipient);
});

Deno.test("curve - decode bad recipient", () => {
  const a = createCurve() as CurveKP;
  assertThrowsErrorCode(() => {
    const key = new TextEncoder().encode("hello world");
    a.decodePubCurveKey(new TextDecoder().decode(base32.encode(key)));
  }, NKeysErrorCode.InvalidRecipient);
});

Deno.test("curve - decode bad recipient - crc", () => {
  const bad = "XBJKZV6QJMJAN3H3KFL2LFVJEQ4WW22423DKRNYF4OIB6LWHUC4COBP6";
  const a = createCurve() as CurveKP;
  assertThrowsErrorCode(() => {
    a.decodePubCurveKey(bad);
  }, NKeysErrorCode.InvalidRecipient);
});

Deno.test("curve - private key", () => {
  const expected = "PBEVILKW5DOTWXGPO6KKZLF7LWB2YAFNC4KC5V4LX77MQ6BKSHZLGV6X";
  const ck = fromSeed(
    new TextEncoder().encode(
      "SXAESVBNK3UN2O24Z53ZJLFMX5OYHLAAVULRILWXRO775SDYFKI7FM3J7Y",
    ),
  );
  const priv = new TextDecoder().decode(ck.getPrivateKey());
  assertEquals(priv, expected);
});

Deno.test("curve - private key cleared", () => {
  const ck = createCurve();
  ck.clear();
  assertThrowsErrorCode(() => {
    ck.getPrivateKey();
  }, NKeysErrorCode.ClearedPair);
});

Deno.test("curve - fromCurveSeed bad key", () => {
  const a = createAccount();
  assertThrowsErrorCode(() => {
    fromCurveSeed(a.getSeed());
  }, NKeysErrorCode.InvalidCurveSeed);
});

Deno.test("curve - basics", () => {
  const sender = createCurve();
  const recipient = createCurve();

  const data = new TextEncoder().encode("hello world");
  const edata = sender.seal(data, recipient.getPublicKey());
  const ddata = recipient.open(edata, sender.getPublicKey());
  assertEquals(data, ddata);
});
