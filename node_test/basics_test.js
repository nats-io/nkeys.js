/*
 * Copyright 2018-2024 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
const test = require("node:test");
const assert = require("node:assert");

const {
  createAccount,
  createOperator,
  createUser,
  fromPublic,
  fromSeed,
  decode,
  encode,
  NKeysErrorCode,
} = require("../lib/mod");
const {
  createCluster,
  createServer,
  Prefix,
} = require("../lib/nkeys");

const { Codec } = require("../lib/codec");

function throws(fn, errCode) {
  try {
    fn();
  } catch (err) {
    const { code } = err;
    assert.strictEqual(code, errCode);
  }
}

function testClear(kp) {
  kp.clear();

  throws(() => {
    kp.getPublicKey();
  }, NKeysErrorCode.ClearedPair);

  throws(() => {
    kp.getPrivateKey();
  }, NKeysErrorCode.ClearedPair);

  throws(() => {
    kp.getSeed();
  }, NKeysErrorCode.ClearedPair);

  throws(() => {
    const data = new TextEncoder().encode("hello");
    kp.sign(data);
  }, NKeysErrorCode.ClearedPair);

  throws(() => {
    const data = new TextEncoder().encode("hello");
    const sig = kp.sign(data);
    kp.verify(data, sig);
  }, NKeysErrorCode.ClearedPair);
}

function doTest(kp, kind) {
  assert.ok(kp);

  const seed = kp.getSeed();
  assert.strictEqual(seed[0], "S".charCodeAt(0));
  assert.strictEqual(seed[1], kind.charCodeAt(0));

  const publicKey = kp.getPublicKey();
  assert.strictEqual(publicKey[0], kind.charAt(0));

  const data = new TextEncoder().encode("HelloWorld");
  const sig = kp.sign(data);
  assert.strictEqual(sig.length, 64);
  assert.strictEqual(kp.verify(data, sig), true);

  const sk = fromSeed(seed);
  assert.strictEqual(sk.verify(data, sig), true);

  const pub = fromPublic(publicKey);
  assert.strictEqual(pub.getPublicKey(), publicKey);
  assert.strictEqual(pub.verify(data, sig), true);

  throws(() => {
    pub.getPrivateKey();
  }, NKeysErrorCode.PublicKeyOnly);
  assert.strictEqual(pub.verify(data, sig), true);

  throws(() => {
    pub.getSeed();
  }, NKeysErrorCode.PublicKeyOnly);

  testClear(kp);
  testClear(pub);
}

test("basics - operator", () => {
  doTest(createOperator(), "O");
});

test("basics - account", () => {
  doTest(createAccount(), "A");
});

test("basics - user", () => {
  doTest(createUser(), "U");
});

test("basics - cluster", () => {
  doTest(createCluster(), "C");
});

test("basics - server", () => {
  doTest(createServer(), "N");
});

test("integration - verify", () => {
  const data = {
    "seed": "SAAFYOZ5U4UBAJMHPITLSKDWAFBJNWH53K7LPZDQKOC5TXAGBIP4DY4WCA",
    "public_key": "AAASUT7FDZDS6UCTBE7JQS2G6KUZBJC5YW7VFVK45JLUK3UDVA6NXJWD",
    "private_key":
      "PBODWPNHFAICLB32E24SQ5QBIKLNR7O2X236I4CTQXM5YBQKD7A6GAJKJ7SR4RZPKBJQSPUYJNDPFKMQURO4LP2S2VOOUV2FN2B2QPG3AHUA",
    "nonce": "uPMbFqF4nSX75B0Nlk9uug==",
    "sig":
      "y9t/0VxLZET6fYlSL7whq52TSv8tP7FBXZdqbQhfdpKCa3pveV7889zqkpiQcv8ivwtACQwumPe6EgrxFc7yDw==",
  };

  const te = new TextEncoder();
  const pk = fromPublic(data.public_key);
  const nonce = te.encode(data.nonce);
  const sig = decode(data.sig);
  assert.strictEqual(pk.verify(nonce, sig), true);

  const seed = fromSeed(te.encode(data.seed));
  assert.strictEqual(seed.verify(nonce, sig), true);
  const sig2 = seed.sign(nonce);
  const encsig = encode(sig2);
  assert.strictEqual(encsig, data.sig);
});

test("integration - encoded seed returns stable values albertor", () => {
  const data = {
    "seed": "SUAGC3DCMVZHI33SMFWGEZLSORXXEYLMMJSXE5DPOJQWYYTFOJ2G64VAPY",
    "public_key": "UAHJLSMYZDJCBHQ2SARL37IEALR3TI7VVPZ2MJ7F4SZKNOG7HJJIYW5T",
    "private_key":
      "PBQWYYTFOJ2G64TBNRRGK4TUN5ZGC3DCMVZHI33SMFWGEZLSORXXEDUVZGMMRURATYNJAIV57UCAFY5ZUP22X45GE7S6JMVGXDPTUUUMRKXA",
    "nonce": "P6Gz7PfS+Cqt0qTgheqa9w==",
    "sig":
      "Dg8/bNrSx/TqBiETRjkVIa3+vx8bQc/DcoFBuFfUiHAEWDsSkzNLgseZlP+x9ndVCoka6YpDIoTzc5NjHTgPCA==",
  };

  const td = new TextDecoder();
  const v = Codec.encodeSeed(
    Prefix.User,
    new TextEncoder().encode("albertoralbertoralbertoralbertor"),
  );
  assert.strictEqual(td.decode(v), data.seed);

  const kp = fromSeed(v);
  assert.strictEqual(td.decode(kp.getSeed()), data.seed, "seed");
  assert.strictEqual(kp.getPublicKey(), data.public_key, "public key");
  assert.strictEqual(
    td.decode(kp.getPrivateKey()),
    data.private_key,
    "private key",
  );
});

test("integration - curve encrypt", () => {
  // this is actual data generated by the nkeys go library
  const expected = [
    120,
    107,
    118,
    49,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    103,
    188,
    195,
    73,
    0,
    3,
    119,
    91,
    181,
    167,
    162,
    167,
    105,
    51,
    102,
    84,
    94,
    152,
    189,
    229,
    149,
    222,
    47,
    17,
    149,
    188,
    170,
  ];
  const secret = "SXAESVBNK3UN2O24Z53ZJLFMX5OYHLAAVULRILWXRO775SDYFKI7FM3J7Y";
  const recipient =
    "SXAHMGVNIYUF4CA5G475EN64YWNG32HSIF4MZCPZHV7PAFYTWBE5J5USFE";

  // parse the imported secret and public
  const kp = fromSeed(new TextEncoder().encode(secret));
  const kp2 = fromSeed(new TextEncoder().encode(recipient));
  const pub2 = kp2.getPublicKey();

  // nonce is 24 empty bytes for ease of inspection
  const nonce = new Uint8Array(24);
  const data = new TextEncoder().encode("hello world");

  const enc = kp.seal(data, pub2, nonce);
  assert.deepEqual(enc, new Uint8Array(expected));
});

test("integration - curve decrypt", () => {
  // this is actual data generated by the nkeys go library
  const message = [
    120,
    107,
    118,
    49,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    103,
    188,
    195,
    73,
    0,
    3,
    119,
    91,
    181,
    167,
    162,
    167,
    105,
    51,
    102,
    84,
    94,
    152,
    189,
    229,
    149,
    222,
    47,
    17,
    149,
    188,
    170,
  ];
  const sender = "SXAESVBNK3UN2O24Z53ZJLFMX5OYHLAAVULRILWXRO775SDYFKI7FM3J7Y";
  const secret = "SXAHMGVNIYUF4CA5G475EN64YWNG32HSIF4MZCPZHV7PAFYTWBE5J5USFE";

  // parse the imported secret and public
  const kp = fromSeed(new TextEncoder().encode(secret));
  const kp2 = fromSeed(new TextEncoder().encode(sender));
  const senderPK = kp2.getPublicKey();

  const enc = kp.open(new Uint8Array(message), senderPK) ?? new Uint8Array();
  assert.strictEqual(new TextDecoder().decode(enc), "hello world");
});
